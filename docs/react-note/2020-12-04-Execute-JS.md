---
order: 10
title: JS底层执行
group:
    title: JS函数底层执行机制
    order: 1
---

# JS运行的环境
+ 浏览器
+ webview  WebApp(Hybride混合APP) 
+ node.js

* 浏览器能够运行JS代码，是因为提供了代码运行的环境：栈内存（Stack）  
    + 栈内存也是从计算机的内存分配出来的一块内存
    + 执行环境栈 **E（execution）C（context）Stack**
    
* 执行代码的过程中，为了区分是在哪个环境下执行（全局/函数/块...），首先会产生一个执行上下文：**EC**
    + EC(G) 全局上下文，全局代码在这执行
    + EC(X) 某个函数的执行上下文

```
var a = 12;
var b = a;
b = 13;
console.log(a);
```
[等号赋值经历三个步骤](20201204/1.png)  
1. 创建值
1. 声明变量
1. 赋值

# Heap
提供一个16进制得地址，存放在stack中，供调用。

```
var a = {
    n: 12
}; //a -> 0x0001

var b = a;
b = { // 开辟一个heap
    n: 13
}; //b -> 0x0002
console.log(a.n); // 12
```

[堆与栈](20201204/2.png)   

#### 思考：

```
var a = {
    n: 1
};
var b = a;
a.x = a = {
    // 先创建了{n: 2}的heap，让a地址中的X存储该heap地址；然后a地址被改为了该heap地址。
    n: 2
};
console.log(a.x);
console.log(b);
```

* a.x 成员访问，优先级20「优先计算的」
  + a.x=a=?  先处理a.x=?
  + a=a.x=?  先处理a.x=?
**都是先算「.」运算符**

```
var a = 12,
    b = 12;
// var a=12;  var b=12;
```

* `var a = b = 12`var a;  b没有var
 + 1.创建值12
 + 2.连等操作是按照从右到左
    先b -> 12，然后a -> 12

[运算符优先级](https://developer.mozilla.org/zh-CN/docs/web/javascript/reference/operators/operator_precedence)  


# 底层执行机制

[例题](20201206/1.png)  

```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);
console.log(b);
```

### PS：

1. 要注意的是，「.」的优先级要高。所以`a.x = a = {n: 2}`赋值的时候，要先赋值给`a.x`

1. 先创建值，在创建变量

1. **全局上下文**只能在页面关闭的时候，出栈释放。（或页面刷新）

# GO —— Global Object

_加载页面_ 的时候就会创建GO，浏览器供JS调用的API，_都放在这里_。

1. GO是一个Heap，区别于全局变量对象（VOG）

1. [关系图](20201206/1.png)   

1. 两者之间的联系靠的是`window`，浏览器在VOG中创建了window这个变量，它指向GO。

1. BOM大多都在GO中


# 函数
[关系图](20201206/2.png)   
例题：
```
var x = [12, 23];
function fn(y) {
    y[0] = 100;
    y = [100];
    y[1] = 200;
    console.log(y);
}
fn(x);
console.log(x);
```
结果：
```
[Log] [100, 200]
[Log] [100, 23]
// 全局的被改变
```
* 正常函数的创建`function fn(){}`

* 匿名函数表达式`var fn = function(){}`

### PS：
1. 两者区别在于后者的变量提升，但是使用let const后区别不大
1. 在哪个上下文中创建的，作用域就是谁
*输出详细信息的语句*`dir(fn)`

### 函数创建步骤:
1. 创建一个函数(值/对象)
+ 创建一个堆内存
+ 声明函数作用域「在哪个上下文创建的，其作用域就是谁」
+ 存储东西:存代码**代码的字符串**
+ 把16进制地址存放到栈中供变量引用

1. 声明一个变量fn (函数名其实也是变量名)  
1. 关联

函数在那个上下文创建的，作用域就是谁。

### 普通函数执行:
1. **形成一个全新的私有上下文**(封装为函数的目的)
+ EC(未知的上下文) -> 进栈执行
+ **AO(Active Object)**变量对象

1. 代码执行前处理的事：
+ 初始化作用域链
+ 声明THIS指向
+ 初始arguments实参集合（类数组集合）
+ 形参赋值
+ 变量提升

1. 代码执行
1. 出栈/不出栈（GC、闭包···）

## scope-chain

 <EC(FN1),EC(G)> 
 两端: 左侧是**当前自己的上下文**，右侧是**函数作用域**（如下例题1）
 
PS：函数代码执行的时候，如果遇到一-个变量，首先看是否为自己上下文中的变量？

是，以后操作都是自己;
不是，则向上级上下文(作用域)总查找

## 形参实参

形参赋值：形参指向实参的地址

1. 私有变量（都会存到AO中）
    + 形参变量（私有变量）
    + 在当前上下文中声明的变量
    + 变量提升阶段
    + 代码执行阶段

#### 例题1
[关系图](20201206/1.js)   

```
/*
 * EC(G)
 *   i=0
 *   A=0x000A [[scope]]:EC(G)
 *   y=0x000X
 *   B=0x000B [[scope]]:EC(G)
 */
var i = 0;

function A() {
    /*
     * EC(A1):第一次把A执行标记为A1
     *   作用域链:<EC(A1),EC(G)>  
     *   形参赋值:--
     * i=10
     * x=0x000X [[scope]]:EC(A1)
     */
    var i = 10;

    function x() {
        /*
         * EC(X1)
         *   作用域链:<EC(X1),EC(A1)>
         *   形参赋值:-- 
         */
        /*
         * EC(X2)
         *   作用域链:<EC(X2),EC(A1)>
         *   形参赋值:-- 
         */
        console.log(i); //->10 10
    }
    return x;
}
var y = A();
y();

function B() {
    /* 
     * EC(B1)
     *   作用域链:<EC(B1),EC(G)>
     *   形参赋值:--
     * i=20
     */
    var i = 20;
    y();
}
B();
```

i会输出10 10，而不是10 20，是因为：**函数的上级上下文，就是函数创建的地方（作用域），而不是调用/执行的地方**

