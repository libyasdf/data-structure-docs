---
order: 4
title: webpack
group:
    title: webpack
    order: 1
---

# 零配置
```
npm init -y
```
初始化package.json


不将webpack安装到全局，局部项目中打包，用：
```
npx webpack
```
这会去找node_modules/.bin /webpack，内部调用webpack-cli命令。


后半部分呢配置在package.json中，就可以变成脚本使用。如：
```
npm run dev
```
# 文件指纹

三种：**hash chunkHash contentHash**如：
```
'bundle.[contentHash:8].js'
```
如果在`HtmlWebpackPlugin`中加`hash: true`，就会自动加hash。

# log

```
node "/user/webpack.config.js"
```
可以打印出，配置文件中的`console.log`

不要去掉`path.resolve`直接写`__dirname`，`path.resolve(__dirname,'dist')`才是绝对地址。

# clean-webpack-plugin
```
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

······

plugins: [
    new CleanWebpackPlugin()
]
```
>先删除打包文件，再打包。

# 如何实现自动化打包

>weboack-dev-server 创建本地服务器 自动重新构建 (打开浏览器，刷新)
```
devServer: {// 在（浏览器）内存中打包 所有的内容在根目录下
    port: 777,
    open: true,
    compress: trus,
    contentBase: 'static',// 启动配置访问一个静态资源文件
    hot: true
}
```

# 多入口文件

```
entry: {
    index: './src/index.html',
    other: './src/other.html'
}

output: {
    filename: '[name].js',
    path: path.resolve(__dirname,"dist")
}
```
然后有多少个入口文件，new多少个：
```
new HtmlWebpackPlugin({
    template: "./other.html",
    hash: true,
    filename: "other.html",
    chunks:['other'],
    minify: { // 打包后的文件 去掉一点儿东西
        removeAttributeQuotes: true, // 比如删除引号
        collapseWhitespace: true // 删除空格
    }
})
```
数量大怎么处理：
```
let htmlPlugin = ['index','other'].map(chunkName => {
    return new HtmlWebpackPlugin({
        template: `./${other}.html`,
        hash: true,
        filename: `${chunkName}.html`,
        chunks:[chunkName],
        minify: { // 打包后的文件 去掉一点儿东西
            removeAttributeQuotes: true, // 比如删除引号
            collapseWhitespace: true // 删除空格
        }
    })
})
```
然后再plugin处解构：
```
...htmlPlugin
```
# 样式配置（前缀、抽离、压缩）
 style-loader css-loader  
 less less-loader  
 node-sass sass-loader  
 styleus styleus-loader  

```
module:{
    rules:[// 执行顺序从下往上 从右往左
        {
            use: ['style-loader','css-loader']// {需要设置更多的参数} '只有一个loader' []
            enforce: 'post'// pre优先加载 post最后加载
        }, {
            use: ['postcss-loader']
        }
    ]
}
```

### 前缀
postcss-loader   （私有前缀插件）
(样式处理工具) autoprefixer
```
postcss.config.js// 自己有一个配置文件
// 设置处理样式的配置文件
module.exports = {
    plugins: [
        require('autoprefixer')
    ]
}
```

```
webpack.config.js

{
    test: /\.css$/,
    use: ['styled-loader',
    {
        loader: MiniCssExtractPlugin.loader
    },
    {
        loader: 'css-loader',
        options: {
            importLoader: 2 // 用后面一个加载器来解析
        }
    },'postcss-loader','less-loader'
    ]
}
```
当浏览器版本高，加的前缀不会很全，所以加上下面的文件，扩大**浏览器适配范围**，css3中各种前缀，适配各种浏览器。
```
.browserslistrc
cover 99.99%
```

### 抽离
分离css插件：mini-css-extract-plugin
```
new MiniCssExtractPlugin({
    filename: 'css/main.css' // 设置分离出的css文件名和目录
})
```

加上这个时候，style-loader就不需要了
``` 
{
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              // 这里可以指定一个 publicPath
              // 默认使用 webpackOptions.output中的publicPath
              publicPath: '../'
            },
          },
          'css-loader',
        ],
      }
```

### 压缩
optimize-css-assets-webpack-plugin // css
terser-webpack-plugin // js
```
optimization: {
    minimizer: [// 压缩css js
        new OptimizeCssAssetsWebpackPlugin()
    ]
}
```
# 兼容IE 

[找不到标识符-default](https://github.com/zuojj/fedlab/issues/5)  
[Is your Vue app not working in IE 11? Here’s how to fix it.](https://jacklyons.me/how-to-fix-vuejs-not-working-in-ie11/#how-to-transpile-your-vue-code)  
[vue cli](https://cli.vuejs.org/config/#runtimecompiler)  
[core-js](https://www.cnblogs.com/sefaultment/p/11631314.html)  

>IE浏览器有一个兼容性配置，将不兼容的网站，存入

